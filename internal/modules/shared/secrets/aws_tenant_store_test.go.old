package secrets

import (
	"context"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/secretsmanager"
	"github.com/aws/aws-sdk-go-v2/service/secretsmanager/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"

	"github.com/gaborage/go-bricks/config"
	"github.com/gaborage/go-bricks/logger"
)

// MockSecretsManagerAPI implements SecretsManagerAPI for testing
type MockSecretsManagerAPI struct {
	mock.Mock
}

func (m *MockSecretsManagerAPI) GetSecretValue(ctx context.Context, params *secretsmanager.GetSecretValueInput, optFns ...func(*secretsmanager.Options)) (*secretsmanager.GetSecretValueOutput, error) {
	args := m.Called(ctx, params)
	return args.Get(0).(*secretsmanager.GetSecretValueOutput), args.Error(1)
}

func (m *MockSecretsManagerAPI) ListSecrets(ctx context.Context, params *secretsmanager.ListSecretsInput, optFns ...func(*secretsmanager.Options)) (*secretsmanager.ListSecretsOutput, error) {
	args := m.Called(ctx, params)
	return args.Get(0).(*secretsmanager.ListSecretsOutput), args.Error(1)
}

func TestAWSSecretsTenantStore_DBConfig(t *testing.T) {
	tests := []struct {
		name           string
		tenantID       string
		secretValue    string
		secretError    error
		expectedError  string
		expectedConfig *config.DatabaseConfig
	}{
		{
			name:     "successful_postgres_config",
			tenantID: "tenant1",
			secretValue: `{
				"type": "postgresql",
				"host": "postgres-tenant1",
				"port": 5432,
				"database": "tenant1_db",
				"username": "tenant1_user",
				"password": "tenant1_pass",
				"pool": {
					"max": {"connections": 20},
					"idle": {"connections": 5, "time": "30m"}
				}
			}`,
			expectedConfig: &config.DatabaseConfig{
				Type:     "postgresql",
				Host:     "postgres-tenant1",
				Port:     5432,
				Database: "tenant1_db",
				Username: "tenant1_user",
				Password: "tenant1_pass",
				Pool: config.PoolConfig{
					Max:  config.PoolMaxConfig{Connections: 20},
					Idle: config.PoolIdleConfig{Connections: 5, Time: 30 * time.Minute},
				},
			},
		},
		{
			name:     "successful_oracle_config",
			tenantID: "tenant2",
			secretValue: `{
				"type": "oracle",
				"host": "oracle-tenant2",
				"port": 1521,
				"database": "XE",
				"username": "tenant2_user",
				"password": "tenant2_pass",
				"oracle": {
					"service": {"name": "XE"}
				}
			}`,
			expectedConfig: &config.DatabaseConfig{
				Type:     "oracle",
				Host:     "oracle-tenant2",
				Port:     1521,
				Database: "XE",
				Username: "tenant2_user",
				Password: "tenant2_pass",
				Oracle: config.OracleConfig{
					Service: config.ServiceConfig{Name: "XE"},
				},
			},
		},
		{
			name:          "empty_tenant_id",
			tenantID:      "",
			expectedError: "tenant ID cannot be empty",
		},
		{
			name:          "secret_not_found",
			tenantID:      "nonexistent",
			secretError:   &types.ResourceNotFoundException{},
			expectedError: "secret not found for tenant nonexistent",
		},
		{
			name:          "invalid_json",
			tenantID:      "tenant3",
			secretValue:   `{invalid json`,
			expectedError: "failed to parse secret JSON for tenant tenant3",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup
			mockClient := &MockSecretsManagerAPI{}
			testLogger := logger.NewTestLogger()

			store := &AWSSecretsTenantStore{
				client:      mockClient,
				cache:       NewCache(5*time.Minute, 100),
				prefix:      "/gobricks/test",
				environment: "test",
				logger:      testLogger,
			}

			ctx := context.Background()

			// Setup mock expectations
			if tt.tenantID != "" {
				secretName := "/gobricks/test/tenant1/database"
				if tt.tenantID != "tenant1" {
					secretName = "/gobricks/test/" + tt.tenantID + "/database"
				}

				input := &secretsmanager.GetSecretValueInput{
					SecretId: aws.String(secretName),
				}

				if tt.secretError != nil {
					mockClient.On("GetSecretValue", ctx, input).Return(
						&secretsmanager.GetSecretValueOutput{}, tt.secretError)
				} else if tt.secretValue != "" {
					mockClient.On("GetSecretValue", ctx, input).Return(
						&secretsmanager.GetSecretValueOutput{
							SecretString: aws.String(tt.secretValue),
						}, nil)
				}
			}

			// Execute
			result, err := store.DBConfig(ctx, tt.tenantID)

			// Verify
			if tt.expectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
				assert.Nil(t, result)
			} else {
				require.NoError(t, err)
				require.NotNil(t, result)
				assert.Equal(t, tt.expectedConfig.Type, result.Type)
				assert.Equal(t, tt.expectedConfig.Host, result.Host)
				assert.Equal(t, tt.expectedConfig.Port, result.Port)
				assert.Equal(t, tt.expectedConfig.Database, result.Database)
				assert.Equal(t, tt.expectedConfig.Username, result.Username)
				assert.Equal(t, tt.expectedConfig.Password, result.Password)

				if tt.expectedConfig.Pool.Max.Connections > 0 {
					assert.Equal(t, tt.expectedConfig.Pool.Max.Connections, result.Pool.Max.Connections)
				}
				if tt.expectedConfig.Oracle.Service.Name != "" {
					assert.Equal(t, tt.expectedConfig.Oracle.Service.Name, result.Oracle.Service.Name)
				}
			}

			mockClient.AssertExpectations(t)
		})
	}
}

func TestAWSSecretsTenantStore_Cache(t *testing.T) {
	// Setup
	mockClient := &MockSecretsManagerAPI{}
	testLogger := logger.NewTestLogger()

	store := &AWSSecretsTenantStore{
		client:      mockClient,
		cache:       NewCache(100*time.Millisecond, 100), // Short TTL for testing
		prefix:      "/gobricks/test",
		environment: "test",
		logger:      testLogger,
	}

	ctx := context.Background()
	tenantID := "cache-test"
	secretValue := `{
		"type": "postgresql",
		"host": "test-host",
		"port": 5432,
		"database": "test_db",
		"username": "test_user",
		"password": "test_pass"
	}`

	// Setup mock to be called only once
	mockClient.On("GetSecretValue", ctx, mock.AnythingOfType("*secretsmanager.GetSecretValueInput")).Return(
		&secretsmanager.GetSecretValueOutput{
			SecretString: aws.String(secretValue),
		}, nil).Once()

	// First call should hit AWS
	config1, err := store.DBConfig(ctx, tenantID)
	require.NoError(t, err)
	assert.Equal(t, "postgresql", config1.Type)

	// Second call should use cache (no additional AWS call)
	config2, err := store.DBConfig(ctx, tenantID)
	require.NoError(t, err)
	assert.Equal(t, "postgresql", config2.Type)

	// Wait for cache to expire
	time.Sleep(150 * time.Millisecond)

	// Setup mock for second AWS call after cache expiration
	mockClient.On("GetSecretValue", ctx, mock.AnythingOfType("*secretsmanager.GetSecretValueInput")).Return(
		&secretsmanager.GetSecretValueOutput{
			SecretString: aws.String(secretValue),
		}, nil).Once()

	// Third call should hit AWS again due to cache expiration
	config3, err := store.DBConfig(ctx, tenantID)
	require.NoError(t, err)
	assert.Equal(t, "postgresql", config3.Type)

	mockClient.AssertExpectations(t)
}

func TestAWSSecretsTenantStore_InvalidateCache(t *testing.T) {
	// Setup
	mockClient := &MockSecretsManagerAPI{}
	testLogger := logger.NewTestLogger()

	store := &AWSSecretsTenantStore{
		client:      mockClient,
		cache:       NewCache(5*time.Minute, 100),
		prefix:      "/gobricks/test",
		environment: "test",
		logger:      testLogger,
	}

	ctx := context.Background()
	tenantID := "invalidate-test"
	secretValue := `{
		"type": "postgresql",
		"host": "test-host",
		"port": 5432,
		"database": "test_db",
		"username": "test_user",
		"password": "test_pass"
	}`

	// Setup mock calls
	mockClient.On("GetSecretValue", ctx, mock.AnythingOfType("*secretsmanager.GetSecretValueInput")).Return(
		&secretsmanager.GetSecretValueOutput{
			SecretString: aws.String(secretValue),
		}, nil).Twice() // Expect two calls due to cache invalidation

	// First call
	_, err := store.DBConfig(ctx, tenantID)
	require.NoError(t, err)

	// Invalidate cache
	store.InvalidateCache(tenantID)

	// Second call should hit AWS again
	_, err = store.DBConfig(ctx, tenantID)
	require.NoError(t, err)

	mockClient.AssertExpectations(t)
}

func TestAWSSecretsTenantStore_ListTenants(t *testing.T) {
	// Setup
	mockClient := &MockSecretsManagerAPI{}
	testLogger := logger.NewTestLogger()

	store := &AWSSecretsTenantStore{
		client:      mockClient,
		cache:       NewCache(5*time.Minute, 100),
		prefix:      "/gobricks/test",
		environment: "test",
		logger:      testLogger,
	}

	ctx := context.Background()

	// Setup mock response
	secretList := []types.SecretListEntry{
		{Name: aws.String("/gobricks/test/tenant1/database")},
		{Name: aws.String("/gobricks/test/tenant2/database")},
		{Name: aws.String("/gobricks/test/tenant3/database")},
		{Name: aws.String("/gobricks/test/other/config")}, // Should be ignored
	}

	mockClient.On("ListSecrets", ctx, mock.AnythingOfType("*secretsmanager.ListSecretsInput")).Return(
		&secretsmanager.ListSecretsOutput{
			SecretList: secretList,
		}, nil)

	// Execute
	tenants, err := store.ListTenants(ctx)

	// Verify
	require.NoError(t, err)
	assert.Len(t, tenants, 3)
	assert.Contains(t, tenants, "tenant1")
	assert.Contains(t, tenants, "tenant2")
	assert.Contains(t, tenants, "tenant3")

	mockClient.AssertExpectations(t)
}

func TestSecretDatabaseConfig_Conversion(t *testing.T) {
	store := &AWSSecretsTenantStore{}

	secretConfig := &SecretDatabaseConfig{
		Type:     "postgresql",
		Host:     "test-host",
		Port:     5432,
		Database: "test_db",
		Username: "test_user",
		Password: "test_pass",
		Pool: &struct {
			Max *struct {
				Connections int32 `json:"connections"`
			} `json:"max"`
			Idle *struct {
				Connections int32         `json:"connections"`
				Time        time.Duration `json:"time"`
			} `json:"idle"`
			Lifetime *struct {
				Max time.Duration `json:"max"`
			} `json:"lifetime"`
		}{
			Max: &struct {
				Connections int32 `json:"connections"`
			}{Connections: 20},
			Idle: &struct {
				Connections int32         `json:"connections"`
				Time        time.Duration `json:"time"`
			}{Connections: 5, Time: 30 * time.Minute},
		},
		Query: &struct {
			Slow *struct {
				Threshold time.Duration `json:"threshold"`
				Enabled   bool          `json:"enabled"`
			} `json:"slow"`
			Log *struct {
				Parameters bool `json:"parameters"`
				MaxLength  int  `json:"max"`
			} `json:"log"`
		}{
			Slow: &struct {
				Threshold time.Duration `json:"threshold"`
				Enabled   bool          `json:"enabled"`
			}{Threshold: 200 * time.Millisecond, Enabled: true},
		},
	}

	result := store.toDatabaseConfig(secretConfig)

	assert.Equal(t, "postgresql", result.Type)
	assert.Equal(t, "test-host", result.Host)
	assert.Equal(t, 5432, result.Port)
	assert.Equal(t, "test_db", result.Database)
	assert.Equal(t, "test_user", result.Username)
	assert.Equal(t, "test_pass", result.Password)
	assert.Equal(t, int32(20), result.Pool.Max.Connections)
	assert.Equal(t, int32(5), result.Pool.Idle.Connections)
	assert.Equal(t, 30*time.Minute, result.Pool.Idle.Time)
	assert.Equal(t, 200*time.Millisecond, result.Query.Slow.Threshold)
	assert.True(t, result.Query.Slow.Enabled)
}

func TestBuildSecretName(t *testing.T) {
	store := &AWSSecretsTenantStore{
		prefix: "/gobricks/test",
	}

	tests := []struct {
		tenantID   string
		configType string
		expected   string
	}{
		{"tenant1", "database", "/gobricks/test/tenant1/database"},
		{"tenant-foo", "messaging", "/gobricks/test/tenant-foo/messaging"},
		{"test123", "cache", "/gobricks/test/test123/cache"},
	}

	for _, tt := range tests {
		t.Run(tt.tenantID+"_"+tt.configType, func(t *testing.T) {
			result := store.buildSecretName(tt.tenantID, tt.configType)
			assert.Equal(t, tt.expected, result)
		})
	}
}
